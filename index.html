<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>index</title></head><body><article class="markdown-body"><h1 id="suave-music-store"><a name="user-content-suave-music-store" href="#suave-music-store" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Suave Music Store</h1>
<h2 id="introduction"><a name="user-content-introduction" href="#introduction" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Introduction</h2>
<p>This is a tutorial on how to create an application with <a href="http://fsharp.org">F#</a> and <a href="http://suave.io">Suave.IO</a> framework. <br />
It&rsquo;s inspired by the Music Store tutorial created by the ASP.NET team <a href="http://www.asp.net/mvc/overview/older-versions/mvc-music-store/mvc-music-store-part-1">available here</a>.<br />
Check out this link if you want to find out what the application is going to offer.</p>
<p>Target audience for this tutorial are mainly C# developers familiar with ASP.NET MVC, who want to learn how to write a real application in F#.<br />
You can still benefit from the tutorial if you don&rsquo;t have C# / .NET background, however you may find some aspects not clear - From time to time there will be a comparison with how the same functionality could be written in ASP.NET MVC &amp; C#.<br />
No prior experience with F# is required - the tutorial will cover basic concepts of the language.<br />
The tutorial is going to have plenty of references to the awesome <a href="http://fsharpforfunandprofit.com">fsharpforfunandprofit.com</a> WebSite, which includes plenty of articles about F# written by Scott Wlaschin.</p>
<p>For most of the following sections there will be a direct link to a specific tagged commit that contains implementation of the application up to the point.<br />
This allows you to follow along the process of creating the app, and get back on the track in case of any amibiguity.</p>
<p>Visual Studio 2013 is used throughout the tutorial, but of course you can use IDE of your choice.</p>
<p>You&rsquo;re more than welcome to create issues or pull requests for this tutorial <a href="https://github.com/theimowski/SuaveMusicStore">here</a>.</p>
<h2 id="hello-world-from-suave"><a name="user-content-hello-world-from-suave" href="#hello-world-from-suave" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Hello World from Suave</h2>
<p>Suave application can be hosted as a standalone Console Application. <br />
Let&rsquo;s start by creating a Console Application Project named <code>SuaveMusicStore</code> (to keep all the files in single folder, uncheck the option to create folder for solution).<br />
Now we can add NuGet reference to Suave. To do that, in Package Manager Console type: <br />
<code>install-package Suave -version 0.28.1</code>. <br />
Alternatively, you can use the NuGet GUI to find and install the Suave package.<br />
Rename the <code>Program.fs</code> file to <code>App.fs</code> to better reflect the purpose of the file, and replace its contents completely with the following code:</p>
<pre><code>open Suave                 // always open suave
open Suave.Http.Successful // for OK-result
open Suave.Web             // for config

startWebServer defaultConfig (OK &quot;Hello World!&quot;)
</code></pre>

<p>Guess what, if you press F5 to run the project, your application is now up and running!<br />
By default it should be available under <code>http://localhost:8083</code>.<br />
If you browse that url, you should be greeted with the classic <code>Hello World!</code>.<br />
The <code>open</code> statements at the top of the file are the same as <code>using</code> statements in C#.<br />
Note there is no <code>Main</code> method defined in <code>App.fs</code> - what happens here is that the <code>startWebServer</code> function is invoked immediately after the program is run and Suave starts listening for incoming request till the process is killed.</p>
<p><a href="https://github.com/theimowski/SuaveMusicStore/tree/hello_world">Tag - hello_world</a></p>
<h2 id="webpart"><a name="user-content-webpart" href="#webpart" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>WebPart</h2>
<p>You may be wondering what the above code actually does. <code>startWebServer</code> is a function from Suave library of type: <code>SuaveConfig -&gt; WebPart -&gt; unit</code>. This basically means that it takes object of type <code>SuaveConfig</code> as first argument, <code>WebPart</code> as second argument, and returns <code>unit</code>.</p>
<p><code>defaultConfig</code> is a value from the Suave library of type <code>SuaveConfig</code>, and as the name suggest it determines the default configuration of server. For now we only need to know that among other stuff it configures the HTTP binding, meaning that in our case the server is listening on port 8083 on loopback address 127.0.0.1.</p>
<p><code>unit</code> in F# is a type for which there is only one applicable value, namely <code>()</code>. It is analogous to C# <code>void</code>, with the difference that you cannot return <code>void</code>. If you&rsquo;d like to learn more about the <code>unit</code> type and how it differs from <code>void</code>, <a href="https://msdn.microsoft.com/en-us/library/dd483472.aspx">follow this link</a>.</p>
<p>The most interesting part is the <code>WebPart</code>. <code>WebPart</code> is a type alias for the following type: <br />
<code>HttpContext -&gt; Async&lt;HttpContext option&gt;</code><br />
This means that <code>WebPart</code> is actually a function, which takes objects of type <code>HttpContext</code> as its first argument and returns an &ldquo;asynchronous workflow&rdquo; of <code>HttpContext option</code>.</p>
<p><code>HttpContext</code> gathers information about the incoming request, outcoming response and other data.<br />
<code>Async</code>, which is often called &ldquo;asynchronous workflow&rdquo; is a concept like &ldquo;promise&rdquo; or &ldquo;future&rdquo; in some other programming languages. C# 5 introduces the Async / Await feature, which is somewhat similar to F# Async. <a href="http://fsharpforfunandprofit.com/posts/concurrency-async-and-parallel/">Here</a> is a great F# resource on async workflows and asynchronous programming in general. <br />
One of the biggest advantages F# has over C# is that it doesn&rsquo;t allow nulls. F# compiler prevents you from passing null as an argument, and as a result you will no longer have to deal with the infamous <code>NullReferenceException</code>. <br />
But what do you do if you want to say that something may have a value or may not have any value at all?<br />
That&rsquo;s where the <code>Option</code> type comes in. Object of type <code>Option</code> might be: <code>None</code> or <code>Some x</code>.<br />
<code>None</code> means there&rsquo;s no value, <code>Some x</code> means there is a value <code>x</code> and <code>x</code> is not null.</p>
<p>To sum up, one could explain <code>WebPart</code> in these words: </p>
<blockquote>
<p>Based on the http context, we give you a promise (async) of optional resulting http context, where the resulting context is likely to have its response set with regards to the logic of the WebPart itself</p>
</blockquote>
<p>In our case, <code>(OK "Hello World!")</code> is the simplest <code>WebPart</code> possible. No matter what comes in the HttpContext, we always return an async of <code>Some</code> <code>HttpContext</code> with response of HTTP Result <code>200 OK</code> and &ldquo;Hello World!&rdquo; in the response body.</p>
<p>To some extent you could think of the <code>WebPart</code> as a <code>Filter</code> in ASP.NET MVC application, but there&rsquo;s more to it than <code>Filters</code> can do.</p>
<p>If the above explanation of <code>WebPart</code> doesn&rsquo;t yet make much sense to you, or you don&rsquo;t understand why it has such type signature, bear with me - in next sections we&rsquo;ll try to prove that this type turns out to be really handy when it comes to one of the greatest powers of functional programming paradigm: <strong>composability</strong>.</p>
<h2 id="basic-routing"><a name="user-content-basic-routing" href="#basic-routing" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Basic routing</h2>
<p>It&rsquo;s time to extend our WebPart to support multiple routes.<br />
First, let&rsquo;s extract the WebPart and bind it to an identifier. <br />
We can do that by typing:<br />
<code>let webPart = OK "Hello World"</code> <br />
and using the <code>webPart</code> identifier in our call to function <code>startWebServer</code>:<br />
<code>startWebServer defaultConfig webPart</code>.<br />
In C#, one would call it &ldquo;assign webPart to a variable&rdquo;, but in functional world there&rsquo;s really no concept of a variable. Instead, we can &ldquo;bind&rdquo; a value to an identifier, which we can reuse later.<br />
Value, once bound, can&rsquo;t be mutated during runtime.<br />
Now, let&rsquo;s restrict our WebPart, so that the &ldquo;Hello World&rdquo; response is sent only at the root path of our application (<code>localhost:8083/</code> but not <code>localhost:8083/anything</code>):<br />
<code>let webPart = path "/" &gt;&gt;= OK "Hello World"</code><br />
<code>path</code> function is defined in <code>Suave.Http.Applicatives</code> module, thus we need to open it at the beggining of <code>App.fs</code>. <code>Suave.Http</code> and <code>Suave.Types</code> modules will also be crucial - let&rsquo;s open them as well.</p>
<p><code>path</code> is a function of type:<br />
<code>string -&gt; WebPart</code><br />
It means that if we give it a string it will return WebPart.<br />
Under the hood, the function looks at the incoming request and returns <code>Some</code> if the paths match, and <code>None</code> otherwise.<br />
The <code>&gt;&gt;=</code> operator comes also from Suave library. It composes two WebParts into one by first evaluating the WebPart on the left, and applying the WebPart on the right only if the first one returned <code>Some</code>.</p>
<p>Let&rsquo;s move on to configuring a few routes in our application. <br />
To achieve that, we can use the <code>choose</code> function, which takes a list of WebParts, and chooses the first one that applies (returns <code>Some</code>), or if none WebPart applies, then choose will also return <code>None</code>:</p>
<pre><code>let webPart = 
    choose [
        path &quot;/&quot; &gt;&gt;= (OK &quot;Home&quot;)
        path &quot;/store&quot; &gt;&gt;= (OK &quot;Store&quot;)
        path &quot;/store/browse&quot; &gt;&gt;= (OK &quot;Store&quot;)
        path &quot;/store/details&quot; &gt;&gt;= (OK &quot;Details&quot;)
    ]
</code></pre>

<p>In addition to that static string path, we can specify route arguments.<br />
Suave comes with a cool feature called &ldquo;typed routes&rdquo;, which gives you statically typed control over arguments for your route. As an example, let&rsquo;s see how we can add <code>id</code> of an album to the details route:</p>
<p><code>pathScan "/store/details/%d" (fun id -&gt; OK (sprintf "Details: %d" id))</code></p>
<p>This might look familiar to print formatting from C++, but it&rsquo;s more powerful.<br />
What happens here is that the compiler checks the type for the <code>%d</code> argument and complains if you pass it a value which is not an integer.<br />
The WebPart will apply for requests like <code>http://localhost:8083/store/details/28</code><br />
In the above example, there are a few important aspects:<br />
- <code>sprintf "Details: %d" id</code> is statically typed string formatting function, expecting the id as an integer <br />
- <code>(fun id -&gt; OK ...)</code> is an anonymous function or lambda expression if you like, of type <code>int -&gt; WebPart</code><br />
- the lambda expression is passed as the second parameter to <code>pathScan</code> function<br />
- first argument of <code>pathScan</code> function also works as a statically typed format<br />
- type inference mechanism built into F# glues everything together, so that you do not have to mark any type signatures</p>
<p>To clear things up, here is another example of how one could use typed routes in Suave:</p>
<p><code>pathScan "/store/details/%s/%d" (fun a id -&gt; OK (sprintf "Artist: %s; Id: %d" a id))</code></p>
<p>for request <code>http://localhost:8083/store/details/abba/1</code></p>
<p>For more information on working with strings in a statically typed way, visit <a href="http://fsharpforfunandprofit.com/posts/printf/">this site</a></p>
<p>Apart from passing arguments in the route itself, we can use the query part of url:<br />
<code>localhost:8083/store/browse?genre=Disco</code><br />
To do this, let&rsquo;s create a separate WebPart:</p>
<pre><code>let browse =
    request (fun r -&gt;
        match r.queryParam &quot;genre&quot; with
        | Choice1Of2 genre -&gt; OK (sprintf &quot;Genre: %s&quot; genre)
        | Choice2Of2 msg -&gt; BAD_REQUEST msg)
</code></pre>

<p><code>request</code> is a function that takes as parameter a function of type <code>HttpRequest -&gt; WebPart</code>.<br />
A function which takes as an argument another function is often called &ldquo;Higher order function&rdquo;.<br />
<code>r</code> in our lambda represents the <code>HttpRequest</code>. It has a <code>queryParam</code> member function of type <br />
<code>string -&gt; Choice&lt;string,string&gt;</code>. <code>Choice</code> is a type that represents a choice between two types.<br />
Usually you&rsquo;ll find that the first type of <code>Choice</code> is for happy paths, while second means something went wrong.<br />
In our case first string stands for a value of the query parameter, and the second string stands for error message (paramater with given key was not found in query).<br />
We can make use of pattern matching to distinguish between two possible choices.<br />
Pattern matching is yet another really powerful feature, implemented in variety of modern programming languages. <br />
For now we can think of it as a switch statement with binding value to an identifier in one go.<br />
In addition to that, F# compiler will issue an warning in case we don&rsquo;t provide all possible cases (<code>Choice1Of2 x</code> and <code>Choice2Of2 x</code> here).<br />
There&rsquo;s actually much more for pattern matching than that, as we&rsquo;ll discover later.<br />
<code>BAS_REQUEST</code> is a function from Suave library, and it returns WebPart with 400 Bad Request status code response with given message in its body.<br />
We can summarize the <code>browse</code> WebPart as following:<br />
If there is a &ldquo;genre&rdquo; parameter in the url query, return 200 OK with the value of the &ldquo;genre&rdquo;, otherwise return 400 Bad Request with error message.</p>
<p>Now we can compose the <code>browse</code> WebPart with routing WebPart like this:</p>
<p><code>path "/store/browse" &gt;&gt;= browse</code></p>
<p>Eventually we should end up with something similar to: <a href="https://github.com/theimowski/SuaveMusicStore/tree/basic_routing">Tag - basic_routing</a></p>
<h2 id="views"><a name="user-content-views" href="#views" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Views</h2>
<p>We&rsquo;ve seen how to define basic routing in a Suave application. <br />
In this section we&rsquo;ll see how we can deal with returning good looking HTML markup in a HTTP response.<br />
Templating HTML views is quite a big topic itself, that we don&rsquo;t want to go into much details about.<br />
Keep in mind that the concept can be approached in many different ways, and the way presented here is not the only proper way of rendering HTML views.<br />
Having said that, I hope you&rsquo;ll still find the following implementation concise and easy to understand.<br />
In this application we&rsquo;ll use server-side HTML templating with the help of a seperate Suave package called <code>Suave.Experimental</code>.</p>
<blockquote>
<p>Note: As of the time of writing, <code>Suave.Experimental</code> is a separate package. It&rsquo;s likely that next releases of the package will include breaking changes. It&rsquo;s also possible that the modules we&rsquo;re going to use from within the package will be extracted to the core Suave package.</p>
</blockquote>
<p>To use the package, we need to take a dependency on the following NuGet:<br />
<code>install-package Suave.Experimental -version 0.28.1</code></p>
<p>Before we start defining views, let&rsquo;s organize our <code>App.fs</code> source file by adding following line at the beginning of the file:</p>
<pre><code>module SuaveMusicStore.App

open Suave
...
</code></pre>

<p>The line means that whatever we define in the file will be placed in <code>SuaveMusicStore.App</code> module.<br />
Read <a href="http://fsharpforfunandprofit.com/posts/recipe-part3/">here</a> for more info about organizing and structuring F# code.<br />
Now let&rsquo;s add a new file <code>View.fs</code> to the project just before the <code>App.fs</code> file and place the following module definition at the very top:</p>
<pre><code>module SuaveMusicStore.View
</code></pre>

<p>We&rsquo;ll follow this convention throughout the tutorial to have a clear understanding of the project structure.</p>
<blockquote>
<p>Note: It&rsquo;s very important that the <code>View.fs</code> file comes before <code>App.fs</code>. F# compiler requires the referenced items to be defined before their usage. At first glance, that might seem like a big drawback, however after a while you start realizing that you can have much better control of your dependencies. Read the <a href="http://fsharpforfunandprofit.com/posts/cyclic-dependencies/">following</a> for further benefits of lack of cyclic dependencies in F# project.</p>
</blockquote>
<p>With the <code>View.fs</code> file in place, let&rsquo;s add our first view:</p>
<pre><code>module SuaveMusicStore.View

open Suave.Html

let divId id = divAttr [&quot;id&quot;, id]
let h1 xml = tag &quot;h1&quot; [] xml
let aHref href = tag &quot;a&quot; [&quot;href&quot;, href]

let index = 
    html [
        head [
            title &quot;Suave Music Store&quot;
        ]

        body [
            divId &quot;header&quot; [
                h1 (aHref &quot;/&quot; (text &quot;F# Suave Music Store&quot;))
            ]

            divId &quot;footer&quot; [
                text &quot;built with &quot;
                aHref &quot;http://fsharp.org&quot; (text &quot;F#&quot;)
                text &quot; and &quot;
                aHref &quot;http://suave.io&quot; (text &quot;Suave.IO&quot;)
            ]
        ]
    ]
    |&gt; xmlToString
</code></pre>

<p>This will serve as a common layout in our application.<br />
A few remarks about the above snippet:</p>
<ul>
<li>open <code>Suave.Html</code> module, for functions to generate HTML markup.</li>
<li>3 helper functions come next:<ul>
<li><code>divId</code> which appends &ldquo;div&rdquo; element with a string attribute <code>id</code></li>
<li><code>h1</code> which takes inner markup to generate HTML header level 1.</li>
<li><code>aHref</code> which takes string attribute <code>href</code> and inner HTML markup to output &ldquo;a&rdquo; element.</li>
</ul>
</li>
<li><code>tag</code> function comes from Suave. It&rsquo;s of type <code>string -&gt; Attribute list -&gt; Xml -&gt; Xml</code>. First arg is name of the HTML element, second - a list of attributes, and third - inner markup</li>
<li><code>Xml</code> is an internal Suave type holding object model for the HTML markup</li>
<li><code>index</code> is our representation of HTML markup. </li>
<li><code>html</code> is a function that takes a list of other tags as its argument. So do <code>head</code> and <code>body</code>.</li>
<li><code>text</code> serves outputing plain text into an HTML element.</li>
<li><code>xmlToString</code> transformates the object model into the resulting raw HTML string.</li>
</ul>
<blockquote>
<p>Note: <code>tag</code> function from Suave takes 3 arguments ().<br />
We&rsquo;ve defined the <code>aHref</code> function by invoking <code>tag</code> with only 2 arguments, and the compilator is perfectly happy with that - Why?<br />
This concept is called &ldquo;partial application&rdquo;, and allows us to invoke a function by passing only a subset of arguments.<br />
When we invoke a function with only a subset of arguments, the function will return another function that will expect the rest of arguments.<br />
In our case this means <code>aHref</code> is of type <code>string -&gt; Xml -&gt; Xml</code>, so the second &ldquo;hidden&rdquo; argument to <code>aHref</code> is of type <code>Xml</code>.<br />
Read <a href="http://fsharpforfunandprofit.com/posts/partial-application/">here</a> for more info about partial application.</p>
</blockquote>
<p>We can see usage of the &ldquo;pipe&rdquo; operator <code>|&gt;</code> in the above code. <br />
The operator might look familiar if you have some UNIX background.<br />
In F#, the <code>|&gt;</code> operator basically means: take the value on the left side and apply it to the function on the right side of the operator.<br />
In this very case it simply means: invoke the <code>xmlToString</code> function on the HTML object model.</p>
<p>Let&rsquo;s test the <code>index</code> view in our <code>App.fs</code>:<br />
<pre><code>    path &quot;/&quot; &gt;&gt;= (OK View.index)
</code></pre></p>
<p>If you navigate to the root url of the application, you should see that proper HTML has been returned.</p>
<p>Before we move on to defining views for the rest of the application, let&rsquo;s introduce one more file - <code>Path.fs</code> and insert it <strong>before</strong> <code>View.fs</code>:</p>
<pre><code>module SuaveMusicStore.Path

type IntPath = PrintfFormat&lt;(int -&gt; string),unit,string,string,int&gt;

let home = &quot;/&quot;

module Store =
    let overview = &quot;/store&quot;
    let browse = &quot;/store/browse&quot;
    let details : IntPath = &quot;/store/details/%d&quot;
</code></pre>

<p>The module will contain all valid routes in our application.<br />
We&rsquo;ll keep them here in one place, in order to be able to reuse both in <code>App</code> and <code>View</code> modules.<br />
Thanks to that, we will minimize the risk of a typo in our <code>View</code> module.<br />
We defined a submodule called <code>Store</code> in order to group routes related to one functionality - later in the tutorial we&rsquo;ll have a few more submodules, each of them reflecting a specific set of functionality of the application.</p>
<p>The <code>IntPath</code> type alias that we declared will let use our routes in conjunction with static-typed Suave routes (<code>pathScan</code> in <code>App</code> module). <br />
We don&rsquo;t need to fully understand the signature of this type, for now we can think of it as a route parametrized with integer value.<br />
And indeed, we annotated the <code>details</code> route with this type, so that the compiler treats this value <em>specially</em>. <br />
We&rsquo;ll see in a moment how we can use <code>details</code> in <code>App</code> and <code>View</code> modules, with the advantage of static typing.</p>
<p>Let&rsquo;s use the routes from <code>Path</code> module in our <code>App</code>:</p>
<pre><code>let webPart = 
    choose [
        path Path.home &gt;&gt;= (OK View.index)
        path Path.Store.overview &gt;&gt;= (OK &quot;Store&quot;)
        path Path.Store.browse &gt;&gt;= browse
        pathScan Path.Store.details (fun id -&gt; OK (sprintf &quot;Details %d&quot; id))
    ]
</code></pre>

<p>as well as in our <code>View</code> for <code>aHref</code> to <code>home</code>:</p>
<pre><code>    divId &quot;header&quot; [
        h1 (aHref Path.home (text &quot;F# Suave Music Store&quot;))
    ]
</code></pre>

<p>Note, that in <code>App</code> module we still benefit from the static typed routes feature that Suave gives us - the <code>id</code> parameter is inferred by the compiler to be of integer type.<br />
If you&rsquo;re not familiar with type inference mechanism, you can follow up <a href="http://fsharpforfunandprofit.com/posts/type-inference/">this link</a>.</p>
<p>It&rsquo;s high time we added some CSS styles to our HTML markup.<br />
We&rsquo;ll not deepdive into the details about the styles itself, as this is not a tutorial on Web Design.<br />
The stylesheet can be downloaded <a href="https://raw.githubusercontent.com/theimowski/SuaveMusicStore/master/Site.css">from here</a> in its final shape.<br />
Add the <code>Site.css</code> stylesheet to the project, and don&rsquo;t forget to set the <code>Copy To Output Directory</code> property to <code>Copy If Newer</code>.</p>
<p>In order to include the stylesheet in our HTML markup, let&rsquo;s add the following to our <code>View</code>:</p>
<pre><code>let cssLink href = linkAttr [ &quot;href&quot;, href; &quot; rel&quot;, &quot;stylesheet&quot;; &quot; type&quot;, &quot;text/css&quot; ]

let index = 
    html [
        head [
            title &quot;Suave Music Store&quot;
            cssLink &quot;/Site.css&quot;
        ]
...
</code></pre>

<p>This enables us to output the link HTML element with <code>href</code> attribute pointing to the CSS stylesheet.</p>
<p>There&rsquo;s two more things before we can see the styles applied on our site.</p>
<p>A browser, when asked to include a CSS file, sends back a request to the server with the given url.<br />
If we have a look at our main <code>WebPart</code> we&rsquo;ll notice that there&rsquo;s really no handler capable of serving this file.<br />
That&rsquo;s why we need to add another alternative to our <code>choose</code> <code>WebPart</code>:</p>
<pre><code>    pathRegex &quot;(.*)\.css&quot; &gt;&gt;= Files.browseHome
</code></pre>

<p>The <code>pathRegex</code> <code>WebPart</code> returns <code>Some</code> if an incoming request concerns path that matches the regular expression pattern. <br />
If that&rsquo;s the case, the <code>Files.browseHome</code> WebPart will be applied.<br />
<code>(.*)\.css</code> pattern matches every file with <code>.css</code> extension.<br />
<code>Files.browseHome</code> is a <code>WebPart</code> from Suave that serves static files from the root application directory.</p>
<p>The CSS depends on <code>logo.png</code> asset, which can be downloaded from <a href="https://raw.githubusercontent.com/theimowski/SuaveMusicStore/master/logo.png">here</a>.</p>
<p>Add <code>logo.png</code> to the project, and again don&rsquo;t forget to select <code>Copy If Newer</code> for <code>Copy To Output Directory</code> property for the asset.<br />
Again, when browser wants to render an image asset, it needs to GET it from the server, so we need to extend our regular expression to allow browsing of <code>.png</code> files as well:</p>
<pre><code>    pathRegex &quot;(.*)\.(css|png)&quot; &gt;&gt;= Files.browseHome
</code></pre>

<p>Now you should be able to see the styles applied to our HTML markup.</p>
<p>With styles in place, let&rsquo;s get our hands on extracting a shared layout for all future views to come.<br />
Start by adding <code>container</code> parameter to <code>index</code> in <code>View</code>:</p>
<pre><code>let index container = 
    html [
...
</code></pre>

<p>and div with id &ldquo;container&rdquo; just after the div &ldquo;header&rdquo;:</p>
<pre><code>    divId &quot;header&quot; [
        h1 (aHref Path.home (text &quot;F# Suave Music Store&quot;))
    ]

    divId &quot;container&quot; container
</code></pre>

<p><code>index</code> previosly was a constant value, but now became a function taking <code>container</code> as parameter.</p>
<p>We can now define actual container for the &ldquo;home&rdquo; page:</p>
<pre><code>let home = [
    text &quot;Home&quot;
]
</code></pre>

<p>For now it will only contain plain &ldquo;Home&rdquo; text.<br />
Let&rsquo;s also extract a common function for creating WebPart, parametrized with the container itself.<br />
Add to <code>App</code> module, just before the <code>browse</code> WebPart the following:</p>
<pre><code>
let html container =
    OK (View.index container)

</code></pre>

<p>Usage for the home page looks like this:</p>
<pre><code>    path Path.home &gt;&gt;= html View.home
</code></pre>

<p>Next, containers for each valid route in our application can be defined in <code>View</code> module:</p>
<pre><code>let home = [
    text &quot;Home&quot;
]

let store = [
    text &quot;Store&quot;
]

let browse genre = [
    text (sprintf &quot;Genre: %s&quot; genre)
]

let details id = [
    text (sprintf &quot;Details %d&quot; id)
]
</code></pre>

<p>Note that both <code>home</code> and <code>store</code> are constant values, while <code>browse</code> and <code>details</code> are parametrized with <code>genre</code> and <code>id</code> respectively.</p>
<p><code>html</code> can be now reused for all 4 views:</p>
<pre><code>let browse =
    request (fun r -&gt;
        match r.queryParam &quot;genre&quot; with
        | Choice1Of2 genre -&gt; html (View.browse genre)
        | Choice2Of2 msg -&gt; BAD_REQUEST msg)

let webPart = 
    choose [
        path Path.home &gt;&gt;= html View.home
        path Path.Store.overview &gt;&gt;= html View.store
        path Path.Store.browse &gt;&gt;= browse
        pathScan Path.Store.details (fun id -&gt; html (View.details id))

        pathRegex &quot;(.*)\.(css|png)&quot; &gt;&gt;= Files.browseHome
    ]
</code></pre>

<p>It&rsquo;s time to replace plain text placeholders in containers with meaningful content.<br />
First, define <code>h2</code> in <code>View</code> module to output HTML header of level 2:</p>
<pre><code>let h2 s = tag &quot;h2&quot; [] (text s)
</code></pre>

<p>and replace <code>text</code> with new <code>h2</code> in each of 4 containers.</p>
<p>We&rsquo;d like the &ldquo;/store&rdquo; route to output hyperlinks to all genres in our Music Store.<br />
Let&rsquo;s add a helper function in <code>Path</code> module, that will be responsible for formatting HTTP url with a key-value parameter:</p>
<pre><code>let withParam (key,value) path = sprintf &quot;%s?%s=%s&quot; path key value
</code></pre>

<p>The <code>withParam</code> function takes a tuple <code>(key,value)</code> as its first argument, <code>path</code> as the second and returns properly formatted url.<br />
A tuple (or a pair) is a widely used structure in F#. It allows us to group two values into one in an easy manner. <br />
Syntax for creating a tuple is following: <code>(item1, item2)</code> - this might look like a standard parameter passing in many other languages including C#.<br />
Follow <a href="http://fsharpforfunandprofit.com/posts/tuples/">this link</a> to learn more about tuples.</p>
<p>Add also a string key for the url parameter &ldquo;/store/browse&rdquo; in <code>Path.Store</code> module:</p>
<pre><code>    let browseKey = &quot;genre&quot;
</code></pre>

<p>We&rsquo;ll use it in <code>App</code> module:</p>
<pre><code>    match r.queryParam Path.Store.browseKey with
    ...
</code></pre>

<p>Now, add the following for working with unordered list (<code>ul</code>) and list item (<code>li</code>) elements in HTML:</p>
<pre><code>let ul xml = tag &quot;ul&quot; [] (flatten xml)
let li = tag &quot;li&quot; []
</code></pre>

<p><code>flatten</code> takes a list of <code>Xml</code> and &ldquo;flattens&rdquo; it into a single <code>Xml</code> object model.<br />
The actual container for <code>store</code> can now look like following:</p>
<pre><code>let store genres = [
    h2 &quot;Browse Genres&quot;
    p [
        text (sprintf &quot;Select from %d genres:&quot; (List.length genres))
    ]
    ul [
        for g in genres -&gt; 
            li (aHref (Path.Store.browse |&gt; Path.withParam (Path.Store.browseKey, g)) (text g))
    ]
]
</code></pre>

<p>Things worth commenting in above snippet:</p>
<ul>
<li><code>store</code> now takes a list of genres (again the type is inferred by the compiler)</li>
<li>the <code>[ for g in genres -&gt; ... ]</code> syntax is known as &ldquo;list comprehension&rdquo;. Here we map every genre string from <code>genres</code> to a list item</li>
<li><code>aHref</code> inside list item points to the <code>Path.Store.browse</code> url with &ldquo;genre&rdquo; parameter - we use the <code>Path.withParam</code> function defined earlier</li>
</ul>
<p>To use <code>View.store</code> from <code>App</code> module, let&rsquo;s simply pass a hardcoded list for <code>genres</code> like following:</p>
<pre><code>    path Path.Store.overview &gt;&gt;= html (View.store [&quot;Rock&quot;; &quot;Disco&quot;; &quot;Pop&quot;])
</code></pre>

<p>Here is what the solution looks like up to this point: <a href="https://github.com/theimowski/SuaveMusicStore/tree/view">Tag - View</a></p>
<h2 id="database"><a name="user-content-database" href="#database" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Database</h2>
<p>In this section we&rsquo;ll see how to add data access to our application.<br />
We&rsquo;ll use SQL Server for the database - you can use the Express version bundled with Visual Studio.<br />
Download the <a href="https://raw.githubusercontent.com/theimowski/SuaveMusicStore/master/create.sql"><code>create.sql</code> script</a> to create <code>SuaveMusicStore</code> database.</p>
<p>There are many ways to talk with a database from .NET code including ADO.NET, light-weight libraries like Dapper, ORMs like Entity Framework or NHibernate.<br />
To have more fun, we&rsquo;ll do something completely different, namely try an awesome F# feature called Type Providers.<br />
In short, Type Providers allows to automatically generate a set of types based on some type of schema.<br />
To learn more about Type Providers, check out <a href="https://msdn.microsoft.com/en-us/library/hh156509.aspx">this resource</a>.</p>
<p>SQLProvider is example of a Type Provider library, which gives ability to cooperate with a relational database.<br />
We can install SQLProvider from NuGet:<br />
<code>install-package SQLProvider -includeprerelease</code></p>
<blockquote>
<p>Note: SQLProvider is marked on NuGet as a &ldquo;prerelease&rdquo;. While it could be risky for more sophisticated queries, we are perfectly fine to use it in our case, as it fullfills all of our data access requirements.</p>
</blockquote>
<p>If you&rsquo;re using Visual Studio, a dialog window can pop asking to confirm enabling the Type Provider. <br />
This is just to notify about capability of the Type Provider to execute its custom code in design time.<br />
To be sure the SQLProvider is referenced correctly, select &ldquo;enable&rdquo;.</p>
<p>Let&rsquo;s also add reference to <code>System.Data</code> assembly.</p>
<p>Having installed the SQLProvider, let&rsquo;s add <code>Db.fs</code> file to the beginning of our project - before any other <code>*.fs</code> file.</p>
<p>In the newly created file, open <code>FSharp.Data.Sql</code> module:</p>
<pre><code>module SuaveMusicStore.Db

open FSharp.Data.Sql
</code></pre>

<p>Next, comes the most interesting part:</p>
<pre><code>type Sql = 
    SqlDataProvider&lt; 
        &quot;Server=(LocalDb)\\v11.0;Database=SuaveMusicStore;Trusted_Connection=True;MultipleActiveResultSets=true&quot;, 
        DatabaseVendor=Common.DatabaseProviderTypes.MSSQLSERVER &gt;
</code></pre>

<p>You&rsquo;ll need to adjust the above connection string, so that it can access the <code>SuaveMusicStore</code> database.<br />
After the SQLProvider can access the database, it will generate a set of types in background - each for single database table, as well as each for single database view.<br />
This might be similar to how Entity Framework generates models for your tables, except there&rsquo;s no explicit code generation involved - all of the types reside under the <code>Sql</code> type defined.</p>
<p>The generated types have a bit cumbersome names, but we can define type aliases to keep things simpler:</p>
<pre><code>type DbContext = Sql.dataContext
type Album = DbContext.``[dbo].[Albums]Entity``
type Genre = DbContext.``[dbo].[Genres]Entity``
type AlbumDetails = DbContext.``[dbo].[AlbumDetails]Entity``
</code></pre>

<p><code>DbContext</code> is our data context.<br />
<code>Album</code> and <code>Genre</code> reflect database tables.<br />
<code>AlbumDetails</code> reflects database view - it will prove useful when we&rsquo;ll need to display names for the album&rsquo;s genre and artist.</p>
<p>With the type aliases set up, we can move forward to creating our first queries:</p>
<pre><code>let firstOrNone s = s |&gt; Seq.tryFind (fun _ -&gt; true)

let getGenres (ctx : DbContext) : Genre list = 
    ctx.``[dbo].[Genres]`` |&gt; Seq.toList

let getAlbumsForGenre genreName (ctx : DbContext) : Album list = 
    query { 
        for album in ctx.``[dbo].[Albums]`` do
            join genre in ctx.``[dbo].[Genres]`` on (album.GenreId = genre.GenreId)
            where (genre.Name = genreName)
            select album
    }
    |&gt; Seq.toList

let getAlbumDetails id (ctx : DbContext) : AlbumDetails option = 
    query { 
        for album in ctx.``[dbo].[AlbumDetails]`` do
            where (album.AlbumId = id)
            select album
    } |&gt; firstOrNone
</code></pre>

<p><code>getGenres</code> is a function for finding all genres. <br />
The function, as well as all functions we&rsquo;ll define in <code>Db</code> module, takes the <code>DbContext</code> as a parameter.<br />
The <code>: Genre list</code> part is a type annotation, which makes sure the function returns a list of <code>Genre</code>s.<br />
Implementation is straight forward:  <code>ctx.``[dbo].[Genres]``</code> queries all genres, so we just need to pipe it to the <code>Seq.toList</code>.</p>
<p><code>getAlbumsForGenre</code> takes <code>genreName</code> as argument (infered to be of type string) and returns a list of <code>Album</code>s.<br />
It makes use of &ldquo;query expression&rdquo; (<code>query { }</code>) which is very similar to C# Linq query.<br />
Read <a href="https://msdn.microsoft.com/en-us/library/hh225374.aspx">here</a> for more info about query expressions.<br />
Inside the query expression, we&rsquo;re performing an inner join of <code>Albums</code> and <code>Genres</code> with the <code>GenreId</code> foreign key, and then we apply a predicate on <code>genre.Name</code> to match the input <code>genreName</code>.<br />
The result of the query is piped to <code>Seq.toList</code>.</p>
<p><code>getAlbumDetails</code> takes <code>id</code> as argument (infered to be of type int) and returns <code>AlbumDetails option</code> because there might be no Album with the given id.<br />
Here, the result of the query is piped to the <code>firstOrNone</code> function, which takes care to transform the result to <code>option</code> type.<br />
<code>firstOrNone</code> verifies if a query returned any result.<br />
In case of any result, <code>firstOrNone</code> will return <code>Some x</code>, otherwise <code>None</code>.</p>
<p>For more convenient instantiation of <code>DbContext</code>, let&rsquo;s introduce a small helper function in <code>Db</code> module:</p>
<pre><code>let getContext() = Sql.GetDataContext()
</code></pre>

<p>Now we&rsquo;re ready to finally read real data in the <code>App</code> module:</p>
<pre><code>let overview =
    Db.getContext() 
    |&gt; Db.getGenres 
    |&gt; List.map (fun g -&gt; g.Name) 
    |&gt; View.store 
    |&gt; html

...

    path Path.Store.overview &gt;&gt;= overview
</code></pre>

<p><code>overview</code> is a WebPart that&hellip; <br />
Hold on, do I really need to explain it?<br />
The usage of pipe operator here makes the flow rather obvious - each line defines each step.<br />
The return value is passed from one function to another, starting with DbContext and ending with the WebPart.<br />
This is just a single example of how composition in functional programming makes functions look like building blocks &ldquo;glued&rdquo; together.</p>
<p>We also need to wrap the <code>overview</code> WebPart in a <code>warbler</code>:</p>
<pre><code>let overview = warbler (fun _ -&gt;
    Db.getContext() 
    |&gt; Db.getGenres 
    |&gt; List.map (fun g -&gt; g.Name) 
    |&gt; View.store 
    |&gt; html)
</code></pre>

<p>That&rsquo;s because our <code>overview</code> WebPart is in some sense static - there is no parameter for it that could influence the outcome.<br />
<code>warbler</code> ensures that genres will be fetched from the database whenever a new request comes.<br />
Otherwise, without the <code>warbler</code> in place, the genres would be fetched only at the start of the application - resulting in stale genres in case the list changes.<br />
How about the rest of WebParts?</p>
<ul>
<li><code>browse</code> is parametrized with the genre name - each request will result in a database query.</li>
<li><code>details</code> is parametrized with the id - the same as above applies.</li>
<li><code>home</code> is just fine - for the moment it&rsquo;s completely static and doesn&rsquo;t need to touch the database.</li>
</ul>
<p>Moving to our next WebPart &ldquo;browse&rdquo;, let&rsquo;s first adjust it in <code>View</code> module:</p>
<pre><code>let browse genre (albums : Db.Album list) = [
    h2 (sprintf &quot;Genre: %s&quot; genre)
    ul [
        for a in albums -&gt;
            li (aHref (sprintf Path.Store.details a.AlbumId) (text a.Title))
    ]
]
</code></pre>

<p>so that it takes two arguments: name of the genre (string) and a list of albums for that genre.<br />
For each album we&rsquo;ll display a list item with a direct link to album&rsquo;s details.</p>
<blockquote>
<p>Note: Here we used the <code>Path.Store.details</code> of type <code>IntPath</code> in conjunction with <code>sprintf</code> function to format the direct link. Again this gives us safety in regards to static typing.</p>
</blockquote>
<p>Now, we can modify the <code>browse</code> WebPart itself:</p>
<pre><code>let browse =
    request (fun r -&gt;
        match r.queryParam Path.Store.browseKey with
        | Choice1Of2 genre -&gt; 
            Db.getContext()
            |&gt; Db.getAlbumsForGenre genre
            |&gt; View.browse genre
            |&gt; html
        | Choice2Of2 msg -&gt; BAD_REQUEST msg)
</code></pre>

<p>Again, usage of pipe operator makes it clear what happens in case the <code>genre</code> is resolved from the query parameter.</p>
<blockquote>
<p>Note: in the example above we adopted &ldquo;partial application&rdquo;, both for <code>Db.getAlbumsForGenre</code> and <code>View.browse</code>. <br />
This could be achieved because the return type between the pipes is the last argument for these functions.</p>
</blockquote>
<p>If you navigate to &ldquo;/store/browse?genre=Latin&rdquo;, you may notice there are some characters displayed incorrectly.<br />
Let&rsquo;s fix this by setting the &ldquo;Content-Type&rdquo; header with correct charset for each HTTP response:</p>
<pre><code>let html container =
    OK (View.index container)
    &gt;&gt;= Writers.setMimeType &quot;text/html; charset=utf-8&quot;
</code></pre>

<p>It&rsquo;s time to read album&rsquo;s details from the database. <br />
Start by adjusting the <code>details</code> in <code>View</code> module:</p>
<pre><code>let details (album : Db.AlbumDetails) = [
    h2 album.Title
    p [ imgSrc album.AlbumArtUrl ]
    divId &quot;album-details&quot; [
        for (caption,t) in [&quot;Genre:&quot;,album.Genre;&quot;Artist:&quot;,album.Artist;&quot;Price:&quot;,formatDec album.Price] -&gt;
            p [
                em caption
                text t
            ]
    ]
]
</code></pre>

<p>Above snippet requires defining a few more helper functions in <code>View</code>:</p>
<pre><code>let imgSrc src = imgAttr [ &quot;src&quot;, src ]
let em s = tag &quot;em&quot; [] (text s)

let formatDec (d : Decimal) = d.ToString(Globalization.CultureInfo.InvariantCulture)
</code></pre>

<p>as well as opening the <code>System</code> namespace at the top of the file.</p>
<blockquote>
<p>Note: It&rsquo;s a good habit to open the <code>System</code> namespace every single time - in practice it usually turns out to be helpful.</p>
</blockquote>
<p>In the <code>details</code> function we used list comprehension syntax with an inline list of tuples (<code>["Genre:",album.Genre;...</code>).<br />
This is just to save us some time from typing the <code>p</code> element three times for all those properties.<br />
You&rsquo;re welcome to change the implementation so that it doesn&rsquo;t use this shortcut if you like.</p>
<p>The <code>AlbumDetails</code> database view turns out to be handy now, because we can use all the attributes we need in a single step (no explicit joins required).</p>
<p>To read the album&rsquo;s details in <code>App</code> module we can do following:</p>
<pre><code>let details id =
    match Db.getAlbumDetails id (Db.getContext()) with
    | Some album -&gt;
        html (View.details album)
    | None -&gt;
        never

...

pathScan Path.Store.details details
</code></pre>

<p>A few remarks regarding above snippet:</p>
<ul>
<li><code>details</code> takes <code>id</code> as parameter and returns WebPart</li>
<li><code>Path.Store.details</code> of type IntPath guarantees type safety</li>
<li><code>Db.getAlbumDetails</code> can return <code>None</code> if no album with given id is found</li>
<li>If an album is found, html WebPart with the <code>View.details</code> container is returned</li>
<li>If no album is found, <code>None</code> WebPart is returned with help of <code>never</code>.</li>
</ul>
<p>No pipe operator was used this time, but as an exercise you can think of how you could apply it to the <code>details</code> WebPart.</p>
<p>Before testing the app, add the &ldquo;placeholder.gif&rdquo; image asset. <br />
You can download it from <a href="https://raw.githubusercontent.com/theimowski/SuaveMusicStore/master/placeholder.gif">here</a>.<br />
Don&rsquo;t forget to set &ldquo;Copy To Output Directory&rdquo;, as well as add new file extension to the <code>pathRegex</code> in <code>App</code> module.</p>
<p>You might have noticed, that when you try to access a missing resource (for example entering album details url with arbitrary album id) then no response is sent.<br />
In order to fix that, let&rsquo;s add a &ldquo;Page Not Found&rdquo; handler to our main <code>choose</code> WebPart as a last resort:</p>
<pre><code>let webPart = 
    choose [
        ...

        html View.notFound
    ]
</code></pre>

<p>the <code>View.notFound</code> can then look like:</p>
<pre><code>let notFound = [
    h2 &quot;Page not found&quot;
    p [
        text &quot;Could not find the requested resource&quot;
    ]
    p [
        text &quot;Back to &quot;
        aHref Path.home (text &quot;Home&quot;)
    ]
]
</code></pre>

<p>Results of the section can be seen here: <a href="https://github.com/theimowski/SuaveMusicStore/tree/database">Tag - Database</a></p>
<h2 id="crud-and-forms"><a name="user-content-crud-and-forms" href="#crud-and-forms" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>CRUD and Forms</h2>
<p>With the database in place, we can now move to implementing a management module.<br />
This will be a simple Create, Update, Delete functionality with a grid to display all albums in the store.</p>
<p>Let&rsquo;s start by adding <code>manage</code> to our <code>View</code> module:</p>
<pre><code>let manage (albums : Db.AlbumDetails list) = [ 
    h2 &quot;Index&quot;
    table [
        yield tr [
            for t in [&quot;Artist&quot;;&quot;Title&quot;;&quot;Genre&quot;;&quot;Price&quot;] -&gt; th [ text t ]
        ]

        for album in albums -&gt; 
        tr [
            for t in [ truncate 25 album.Artist; truncate 25 album.Title; album.Genre; formatDec album.Price ] -&gt;
                td [ text t ]
        ]
    ]
]
</code></pre>

<p>The view requires a few of new helper functions for table HTML markup:</p>
<pre><code>let table x = tag &quot;table&quot; [] (flatten x)
let th x = tag &quot;th&quot; [] (flatten x)
let tr x = tag &quot;tr&quot; [] (flatten x)
let td x = tag &quot;td&quot; [] (flatten x)
</code></pre>

<p>as well as a <code>truncate</code> function that will ensure our cell content doesn&rsquo;t span over a maximum number of characters:</p>
<pre><code>let truncate k (s : string) =
    if s.Length &gt; k then
        s.Substring(0, k - 3) + &quot;...&quot;
    else s
</code></pre>

<p>Remarks:</p>
<ul>
<li>our HTML table consists of first row (<code>tr</code>) containing column headers (<code>th</code>) and a set of rows for each album with cells (<code>td</code>) to display specific values.</li>
<li>we used the <code>yield</code> keyword for the first time. It is required here because we&rsquo;re using it in conjuction with the <code>for album in albums -&gt;</code> list comprehension syntax inside the same list. The rule of thumb is that whenever you use the list comprehension syntax, then you need the <code>yield</code> keyword for any other item not contained in the comprehension syntax. This might seem hard to remember, but don&rsquo;t worry - the compiler is helpful here and will issue a warning if you forget the <code>yield</code> keyword.</li>
<li>for the sake of saving a few keystrokes we used a nested list comprehension syntax to output <code>th</code>s and <code>td</code>s. Again, it&rsquo;s just a matter of taste, and could be also solved by enumerating each element separately</li>
</ul>
<p>We are going to need to fetch the list of all <code>AlbumDetail</code>s from the database. <br />
For this reason, let&rsquo;s create following query in <code>Db</code> module:</p>
<pre><code>let getAlbumsDetails (ctx : DbContext) : AlbumDetails list = 
    ctx.``[dbo].[AlbumDetails]`` |&gt; Seq.toList
</code></pre>

<p>Now we&rsquo;re ready to define an actual handler to display the list of albums.<br />
Let&rsquo;s add a new sub-module to <code>Path</code>:</p>
<pre><code>module Admin =
    let manage = &quot;/admin/manage&quot;
</code></pre>

<p>The <code>Admin</code> sub-module will contain all album management paths or routes if you will.</p>
<p><code>manage</code> WebPart in <code>App</code> module can be implemented in following way:</p>
<pre><code>let manage = warbler (fun _ -&gt;
    Db.getContext()
    |&gt; Db.getAlbumsDetails
    |&gt; View.manage
    |&gt; html)
</code></pre>

<p>and used in the main <code>choose</code> WebPart:</p>
<pre><code>    path Path.Admin.manage &gt;&gt;= manage
</code></pre>

<p>Don&rsquo;t forget about the <code>warbler</code> for <code>manage</code> WebPart - we don&rsquo;t use an parameters for this WebPart, so we need to prevent it&rsquo;s eager evaluation.</p>
<p>If you navigate to the &ldquo;/admin/manage&rdquo; url in the application now, you should be presented the grid with every album in the store.<br />
We can&rsquo;t make any operation on an album yet.<br />
To fix this, let&rsquo;s first add the delete functionality:</p>
<pre><code>let deleteAlbum albumTitle = [
    h2 &quot;Delete Confirmation&quot;
    p [ 
        text &quot;Are you sure you want to delete the album titled&quot;
        br
        strong albumTitle
        text &quot;?&quot;
    ]

    form [
        submitInput &quot;Delete&quot;
    ]

    div [
        aHref Path.Admin.manage (text &quot;Back to list&quot;)
    ]
]
</code></pre>

<p><code>deleteAlbum</code> is to be placed in the <code>View</code> module. It requires new markup functions:</p>
<pre><code>let strong s = tag &quot;strong&quot; [] (text s)

let form x = tag &quot;form&quot; [&quot;method&quot;, &quot;POST&quot;] (flatten x)
let submitInput value = inputAttr [&quot;type&quot;, &quot;submit&quot;; &quot;value&quot;, value]
</code></pre>

<ul>
<li><code>strong</code> is just an emphasis</li>
<li><code>form</code> is HTML element for a form with it&rsquo;s &ldquo;method&rdquo; attribute set to &ldquo;POST&rdquo;</li>
<li><code>submitInput</code> is button to submit a form</li>
</ul>
<p>A couple of snippets to handle <code>deleteAlbum</code> are still needed, starting with <code>Db</code>:</p>
<pre><code>let getAlbum id (ctx : DbContext) : Album option = 
    query { 
        for album in ctx.``[dbo].[Albums]`` do
            where (album.AlbumId = id)
            select album
    } |&gt; firstOrNone
</code></pre>

<p>for getting <code>Album option</code> (not <code>AlbumDetails</code>). <br />
New route in <code>Path</code>:</p>
<pre><code>module Admin =
    let manage = &quot;/admin/manage&quot;
    let deleteAlbum : IntPath = &quot;/admin/delete/%d&quot;
</code></pre>

<p>Finally we can put following in the <code>App</code> module:</p>
<pre><code>let deleteAlbum id =
    match Db.getAlbum id (Db.getContext()) with
    | Some album -&gt;
        html (View.deleteAlbum album.Title)
    | None -&gt;
        never
</code></pre>

<pre><code>    pathScan Path.Admin.deleteAlbum deleteAlbum
</code></pre>

<p>Note that the code above allows us to navigate to to &ldquo;/admin/delete/%d&rdquo;, but we still are not able to actually delete an album.<br />
That&rsquo;s because there&rsquo;s no handler in our app to delete the album from database.<br />
For the moment both GET and POST requests will do the same, which is return HTML page asking whether to delete the album.</p>
<p>In order to implement the deletion, add <code>deleteAlbum</code> to <code>Db</code> module:</p>
<pre><code>let deleteAlbum (album : Album) (ctx : DbContext) = 
    album.Delete()
    ctx.SubmitUpdates()
</code></pre>

<p>The snippet takes an <code>Album</code> as a parameter - instance of this type comes from database, and we can invoke <code>Delete()</code> member on it - SQLProvider keeps track of such changes, and upon <code>ctx.SubmitUpdates()</code> executes necessary SQL commands. This is somewhat similar to the &ldquo;Active Record&rdquo; concept.</p>
<p>Now, in <code>App</code> module we can distinguish between GET and POST requests:</p>
<pre><code>let deleteAlbum id =
    let ctx = Db.getContext()
    match Db.getAlbum id ctx with
    | Some album -&gt;
        choose [ 
            GET &gt;&gt;= warbler (fun _ -&gt; 
                html (View.deleteAlbum album.Title))
            POST &gt;&gt;= warbler (fun _ -&gt; 
                Db.deleteAlbum album ctx; 
                Redirection.FOUND Path.Admin.manage)
        ]
    | None -&gt;
        never
</code></pre>

<ul>
<li><code>deleteAlbum</code> WebPart gets passed the <code>choose</code> with two possibilities. </li>
<li><code>GET</code> and <code>POST</code> are WebParts that succeed (return <code>Some x</code>) only if the incoming HTTP request is of GET or POST verb respectively.</li>
<li>after succesfull deletion of album, the <code>POST</code> case redirects us to the <code>Path.Admin.manage</code> page</li>
</ul>
<blockquote>
<p>Important: We have to wrap both GET and POST handlers with a <code>warbler</code> - otherwise they would be evaluated just after <code>Some album</code> match, resulting in invoking <code>Db.deleteAlbum</code> even if POST does not apply.</p>
</blockquote>
<p>The grid can now contain a column with link to delete the album in question:</p>
<pre><code>table [
        yield tr [
            for t in [&quot;Artist&quot;;&quot;Title&quot;;&quot;Genre&quot;;&quot;Price&quot;;&quot;&quot;] -&gt; th [ text t ]
        ]

        for album in albums -&gt; 
        tr [
            for t in [ truncate 25 album.Artist; truncate 25 album.Title; album.Genre; formatDec album.Price ] -&gt;
                td [ text t ]

            yield td [
                aHref (sprintf Path.Admin.deleteAlbum album.AlbumId) (text &quot;Delete&quot;)
            ]
        ]
    ]
</code></pre>

<ul>
<li>there&rsquo;s a new empty column header in the first row</li>
<li>in the last column of each album row comes a cell with link to delete the album</li>
<li>note, we had to use the <code>yield</code> keyword again</li>
</ul>
<p>We can delete an album, so why don&rsquo;t we proceed to add album functionality now.<br />
It will require a bit more effort, because we actually need some kind of a form with fields to create a new album.<br />
Fortunately, there&rsquo;s a helper module in Suave library exactly for this purpose.</p>
<blockquote>
<p>Note: <code>Suave.Form</code> module at the time of writing is still in <code>Experimental</code> package - just as <code>Suave.Html</code> which we&rsquo;re already using.</p>
</blockquote>
<p>First, let&rsquo;s create a separate module <code>Form</code> to keep all of our forms in there (yes there will be more soon).<br />
Add the <code>Form.fs</code> file just before <code>View.fs</code> - both <code>View</code> and <code>App</code> module will depend on <code>Form</code>.<br />
As with the rest of modules, don&rsquo;t forget to follow our modules naming convention.</p>
<p>Now declare the first <code>Album</code> form:</p>
<pre><code>module SuaveMusicStore.Form

open Suave.Form

type Album = {
    ArtistId : decimal
    GenreId : decimal
    Title : string
    Price : decimal
    ArtUrl : string
}

let album : Form&lt;Album&gt; = 
    Form ([ TextProp ((fun f -&gt; &lt;@ f.Title @&gt;), [ maxLength 100 ])
            TextProp ((fun f -&gt; &lt;@ f.ArtUrl @&gt;), [ maxLength 100 ])
            DecimalProp ((fun f -&gt; &lt;@ f.Price @&gt;), [ min 0.01M; max 100.0M; step 0.01M ])
            ],
          [])
</code></pre>

<p><code>Album</code> type contains all fields needed for the form.<br />
For the moment, <code>Suave.Form</code> supports following types of fields:</p>
<ul>
<li>decimal</li>
<li>string</li>
<li>System.Net.Mail.MailAddress</li>
<li>Suave.Form.Password</li>
</ul>
<blockquote>
<p>Note: the int type is not supported yet, however we can easily convert from decimal to int and vice versa</p>
</blockquote>
<p>Afterwards comes a declaration of the album form (let album : <code>Form&lt;Album&gt;</code> =).<br />
It consists of list of &ldquo;Props&rdquo; (Properties), of which we can think as of validations:</p>
<ul>
<li>First, we declared that the <code>Title</code> must be of max length 100</li>
<li>Second, we declared the same for <code>ArtUrl</code></li>
<li>Third, we declared that the <code>Price</code> must be between 0.01 and 100.0 with a step of 0.01 (this means that for example 1.001 is invalid)</li>
</ul>
<p>Those properties can be now used as both client and server side.<br />
For client side we will the <code>album</code> declaration in our <code>View</code> module in order to output HTML5 input validation attributes.<br />
For server side we will use an utitlity WebPart that will parse the form field values from a request.</p>
<blockquote>
<p>Note: the above snippet uses F# Quotations - a feature that you can read more about <a href="https://msdn.microsoft.com/en-us/library/dd233212.aspx">here</a>.<br />
For the sake of tutorial, you only need to know that they allow Suave to lookup the name of a Field from a property getter.</p>
</blockquote>
<p>To see how we can use the form in <code>View</code> module, add <code>open Suave.Form</code> to the beginning:</p>
<pre><code>module SuaveMusicStore.View

open System

open Suave.Html
open Suave.Form
</code></pre>

<p>Next, add a couple of helper functions:</p>
<pre><code>let divClass c = divAttr [&quot;class&quot;, c]

...

let fieldset x = tag &quot;fieldset&quot; [] (flatten x)
let legend txt = tag &quot;legend&quot; [] (text txt)
</code></pre>

<p>And finally this block of code:</p>
<pre><code>type Field&lt;'a&gt; = {
    Label : string
    Xml : Form&lt;'a&gt; -&gt; Suave.Html.Xml
}

type Fieldset&lt;'a&gt; = {
    Legend : string
    Fields : Field&lt;'a&gt; list
}

type FormLayout&lt;'a&gt; = {
    Fieldsets : Fieldset&lt;'a&gt; list
    SubmitText : string
    Form : Form&lt;'a&gt;
}

let renderForm (layout : FormLayout&lt;_&gt;) =    

    form [
        for set in layout.Fieldsets -&gt; 
            fieldset [
                yield legend set.Legend

                for field in set.Fields do
                    yield divClass &quot;editor-label&quot; [
                        text field.Label
                    ]
                    yield divClass &quot;editor-field&quot; [
                        field.Xml layout.Form
                    ]
            ]

        yield submitInput layout.SubmitText
    ]
</code></pre>

<p>Above snippet is quite long but, as we&rsquo;ll soon see, we&rsquo;ll be able to reuse it a few times.<br />
The <code>FormLayout</code> types defines a layout for a form and consists of:</p>
<ul>
<li><code>SubmitText</code> that will be used for the string value of submit button</li>
<li><code>Fieldsets</code> - a list of <code>Fieldset</code> values</li>
<li><code>Form</code> - instance of the form to render</li>
</ul>
<p>The <code>Fieldset</code> type defines a layout for a fieldset:</p>
<ul>
<li><code>Legend</code> is a string value for a set of fields</li>
<li><code>Fields</code> is a list of <code>Field</code> values</li>
</ul>
<p>The <code>Field</code> type has:</p>
<ul>
<li>a <code>Label</code> string</li>
<li><code>Xml</code> - function which takes <code>Form</code> and returns <code>Xml</code> (object model for HTML markup). It might seem cumbersome, but the signature is deliberate in order to make use of partial application</li>
</ul>
<blockquote>
<p>Note: all of above types are generic, meaning they can accept any type of form, but the form&rsquo;s type must be consistent in the <code>FormLayout</code> hierarchy.</p>
</blockquote>
<p><code>renderForm</code> is a reusable function that takes an instance of <code>FormLayout</code> and returns HTML object model:</p>
<ul>
<li>it creates a form element</li>
<li>the form contains a list of fieldsets, each of which:<ul>
<li>outputs its legend first</li>
<li>iterates over its <code>Fields</code> and<ul>
<li>outputs div element with label element for the field</li>
<li>outputs div element with target input element for the field</li>
</ul>
</li>
</ul>
</li>
<li>the form ends with a submit button</li>
</ul>
<p><code>renderForm</code> ca be invoked like this:</p>
<pre><code>let createAlbum genres artists = [ 
    h2 &quot;Create&quot;

    renderForm
        { Form = Form.album
          Fieldsets = 
              [ { Legend = &quot;Album&quot;
                  Fields = 
                      [ { Label = &quot;Genre&quot;
                          Xml = selectInput (fun f -&gt; &lt;@ f.GenreId @&gt;) genres None }
                        { Label = &quot;Artist&quot;
                          Xml = selectInput (fun f -&gt; &lt;@ f.ArtistId @&gt;) artists None }
                        { Label = &quot;Title&quot;
                          Xml = input (fun f -&gt; &lt;@ f.Title @&gt;) [] }
                        { Label = &quot;Price&quot;
                          Xml = input (fun f -&gt; &lt;@ f.Price @&gt;) [] }
                        { Label = &quot;Album Art Url&quot;
                          Xml = input (fun f -&gt; &lt;@ f.ArtUrl @&gt;) [&quot;value&quot;, &quot;/placeholder.gif&quot;] } ] } ]
          SubmitText = &quot;Create&quot; }

    div [
        aHref Path.Admin.manage (text &quot;Back to list&quot;)
    ]
]
</code></pre>

<p>We can see that for the <code>Xml</code> values we can invoke <code>selectInput</code> or <code>input</code> functions.<br />
Both of them take as first argument function which directs to field for which the input should be generated.<br />
<code>input</code> takes as second argument a list of optional attributes (of type <code>string * string</code> - key and value).<br />
<code>selectInput</code> takes as second argument list of options (of type <code>decimal * string</code> - value and display name).<br />
As third argument, <code>selectInput</code> takes an optional selected value - in case of <code>None</code>, the first one will be selected initially.</p>
<blockquote>
<p>Note: We are hardcoding the album&rsquo;s <code>ArtUrl</code> property with &ldquo;/placeholder.gif&rdquo; - we won&rsquo;t implement uploading images, so we&rsquo;ll have to stick with a placeholder image.</p>
</blockquote>
<p>Now that we have the <code>createAlbum</code> view, we can write the appropriate WebPart handler.<br />
Start by adding <code>getArtists</code> to <code>Db</code>:</p>
<pre><code>type Artist = DbContext.``[dbo].[Artists]Entity``

...

let getArtists (ctx : DbContext) : Artist list = 
    ctx.``[dbo].[Artists]`` |&gt; Seq.toList
</code></pre>

<p>Then proper entry in <code>Path</code> module:</p>
<pre><code>    let createAlbum = &quot;/admin/create&quot;
</code></pre>

<p>and WebPart in <code>App</code> module:</p>
<pre><code>let createAlbum =
    let ctx = Db.getContext()
    choose [
        GET &gt;&gt;= warbler (fun _ -&gt; 
            let genres = 
                Db.getGenres ctx 
                |&gt; List.map (fun g -&gt; decimal g.GenreId, g.Name)
            let artists = 
                Db.getArtists ctx
                |&gt; List.map (fun g -&gt; decimal g.ArtistId, g.Name)
            html (View.createAlbum genres artists))
    ]

...

    path Path.Admin.createAlbum &gt;&gt;= createAlbum
</code></pre>

<p>Once again, <code>warbler</code> will prevent from eager evaluation of the WebPart - it&rsquo;s vital here.<br />
To our <code>View.manage</code> we can add a link to <code>createAlbum</code>:</p>
<pre><code>let manage (albums : Db.AlbumDetails list) = [ 
    h2 &quot;Index&quot;
    p [
        aHref Path.Admin.createAlbum (text &quot;Create New&quot;)
    ]
...
</code></pre>

<p>This allows us to navigate to &ldquo;/admin/create&rdquo;, however we&rsquo;re still lacking the actual POST handler.</p>
<p>Before we define the handler, let&rsquo;s add another helper function to <code>App</code> module:</p>
<pre><code>let bindToForm form handler =
    bindReq (bindForm form) handler BAD_REQUEST
</code></pre>

<p>It requires a few modules to be open, namely:</p>
<ul>
<li><code>Suave.Form</code></li>
<li><code>Suave.Http.RequestErrors</code></li>
<li><code>Suave.Model.Binding</code></li>
</ul>
<p>What <code>bindToForm</code> does is:</p>
<ul>
<li>it takes as first argument a form of type <code>Form&lt;'a&gt;</code></li>
<li>it takes as second argument a handler of type <code>'a -&gt; WebPart</code></li>
<li>if the incoming request contains form fields filled correctly, meaning they can be parsed to corresponding types, and hold all <code>Prop</code>s defined in <code>Form</code> module, then the <code>handler</code> argument is applied with the values of <code>'a</code> filled in</li>
<li>otherwise the 400 HTTP Status Code &ldquo;Bad Request&rdquo; is returned with information about what was mailformed.</li>
</ul>
<p>There are just 2 more things before we&rsquo;re good to go with creating album functionality.</p>
<p>We need <code>createAlbum</code> for the <code>Db</code> module (the created album is piped to <code>ignore</code> function, because we don&rsquo;t need it afterwards):</p>
<pre><code>let createAlbum (artistId, genreId, price, title) (ctx : DbContext) =
    ctx.``[dbo].[Albums]``.Create(artistId, genreId, price, title) |&gt; ignore
    ctx.SubmitUpdates()
</code></pre>

<p>as well as POST handler inside the <code>createAlbum</code> WebPart:</p>
<pre><code>choose [
        GET &gt;&gt;= ...

        POST &gt;&gt;= bindToForm Form.album (fun form -&gt;
            Db.createAlbum (int form.ArtistId, int form.GenreId, form.Price, form.Title) ctx
            Redirection.FOUND Path.Admin.manage)
    ]
</code></pre>

<p>We have delete, we have create, so we&rsquo;re left with the update part only.<br />
This one will be fairly easy, as it&rsquo;s gonna be very similar to create (we can reuse the album form we declared in <code>Form</code> module).</p>
<p><code>editAlbum</code> in <code>View</code>:</p>
<pre><code>let editAlbum (album : Db.Album) genres artists = [ 
    h2 &quot;Edit&quot;

    renderForm
        { Form = Form.album
          Fieldsets = 
              [ { Legend = &quot;Album&quot;
                  Fields = 
                      [ { Label = &quot;Genre&quot;
                          Xml = selectInput (fun f -&gt; &lt;@ f.GenreId @&gt;) genres (Some (decimal album.GenreId)) }
                        { Label = &quot;Artist&quot;
                          Xml = selectInput (fun f -&gt; &lt;@ f.ArtistId @&gt;) artists (Some (decimal album.ArtistId))}
                        { Label = &quot;Title&quot;
                          Xml = input (fun f -&gt; &lt;@ f.Title @&gt;) [&quot;value&quot;, album.Title] }
                        { Label = &quot;Price&quot;
                          Xml = input (fun f -&gt; &lt;@ f.Price @&gt;) [&quot;value&quot;, formatDec album.Price] }
                        { Label = &quot;Album Art Url&quot;
                          Xml = input (fun f -&gt; &lt;@ f.ArtUrl @&gt;) [&quot;value&quot;, &quot;/placeholder.gif&quot;] } ] } ]
          SubmitText = &quot;Save Changes&quot; }

    div [
        aHref Path.Admin.manage (text &quot;Back to list&quot;)
    ]
]
</code></pre>

<p>Path:</p>
<pre><code>    let editAlbum : IntPath = &quot;/admin/edit/%d&quot;    
</code></pre>

<p>Link in <code>manage</code> in <code>View</code>:</p>
<pre><code>for album in albums -&gt; 
        tr [
            ...

            yield td [
                aHref (sprintf Path.Admin.editAlbum album.AlbumId) (text &quot;Edit&quot;)
                text &quot; | &quot;
                aHref (sprintf Path.Admin.deleteAlbum album.AlbumId) (text &quot;Delete&quot;)
            ]
        ]
</code></pre>

<p><code>updateAlbum</code> in <code>Db</code> module:</p>
<pre><code>let updateAlbum (album : Album) (artistId, genreId, price, title) (ctx : DbContext) =
    album.ArtistId &lt;- artistId
    album.GenreId &lt;- genreId
    album.Price &lt;- price
    album.Title &lt;- title
    ctx.SubmitUpdates()
</code></pre>

<p><code>editAlbum</code> WebPart in <code>App</code> module:</p>
<pre><code>let editAlbum id =
    let ctx = Db.getContext()
    match Db.getAlbum id ctx with
    | Some album -&gt;
        choose [
            GET &gt;&gt;= warbler (fun _ -&gt;
                let genres = 
                    Db.getGenres ctx 
                    |&gt; List.map (fun g -&gt; decimal g.GenreId, g.Name)
                let artists = 
                    Db.getArtists ctx
                    |&gt; List.map (fun g -&gt; decimal g.ArtistId, g.Name)
                html (View.editAlbum album genres artists))
            POST &gt;&gt;= bindToForm Form.album (fun form -&gt;
                Db.updateAlbum album (int form.ArtistId, int form.GenreId, form.Price, form.Title) ctx
                Redirection.FOUND Path.Admin.manage)
        ]
    | None -&gt; 
        never
</code></pre>

<p>and finally <code>pathScan</code> in main <code>choose</code> WebPart:</p>
<pre><code>    pathScan Path.Admin.editAlbum editAlbum
</code></pre>

<p>Comments to above snippets:</p>
<ul>
<li><code>editAlbum</code> View looks very much the same as the <code>createAlbum</code>. The only significant difference is that it has all the filed values pre-filled. </li>
<li>in <code>Db.updateAlbum</code> we can see examples of property setters. This is the way SQLProvider mutates our <code>Album</code> value, while keeping track on what has changed before <code>SubmitUpdates()</code></li>
<li><code>warbler</code> is needed in <code>editAlbum</code> GET handler to prevent eager evaluation</li>
<li>but it&rsquo;s not necessary for POST, because POST needs to parse the incoming request, thus the evaluation is postponed upon the successfull parsing.</li>
<li>after the album is updated, a redirection to <code>manage</code> is applied</li>
</ul>
<blockquote>
<p>Note: SQLProvider allows to change <code>Album</code> properties after the object has been instantiated - that&rsquo;s generally against the immutability concept that&rsquo;s propageted in the functional programming paradigm. We need to remember however, that F# is not pure functional programming language, but rather &ldquo;functional first&rdquo;. This means that while it encourages to write in functional style, it still allows to use Object Oriented constructs. This often turns out to be usefull, for example when we need to improve performance.</p>
</blockquote>
<p>As the icing on the cake, let&rsquo;s also add link to details for each of the albums in <code>View.manage</code>:</p>
<pre><code>aHref (sprintf Path.Admin.editAlbum album.AlbumId) (text &quot;Edit&quot;)
text &quot; | &quot;
aHref (sprintf Path.Store.details album.AlbumId) (text &quot;Details&quot;)
text &quot; | &quot;
aHref (sprintf Path.Admin.deleteAlbum album.AlbumId) (text &quot;Delete&quot;)
</code></pre>

<p>Pheeew, this section was long, but also very productive. Looks like we can already do some serious interaction with the application!<br />
Results can be seen here: <a href="https://github.com/theimowski/SuaveMusicStore/tree/crud_and_forms">Tag - crud_and_forms</a></p>
<h2 id="auth-and-session"><a name="user-content-auth-and-session" href="#auth-and-session" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Auth and Session</h2>
<p>In the previous section we succeeded in setting up Create, Update and Delete functionality for albums in the Music Store.<br />
All of these actions are likely to be performed by some kind of shop manager, or administrator.<br />
In fact, <code>Path</code> module defines that all the operations are available under &ldquo;/admin&rdquo; route.<br />
It would be nice if we could authorize only chosen users to mess with albums in our Store.<br />
That&rsquo;s exactly what we&rsquo;ll do right now.</p>
<p>As a warmup, let&rsquo;s add navigation menu at the very top of the view.<br />
We&rsquo;ll call it <code>partNav</code> and keep in separate function:</p>
<pre><code>let partNav = 
    ulAttr [&quot;id&quot;, &quot;navlist&quot;] [ 
        li (aHref Path.home (text &quot;Home&quot;))
        li (aHref Path.Store.overview (text &quot;Store&quot;))
        li (aHref Path.Admin.manage (text &quot;Admin&quot;))
    ]
</code></pre>

<p><code>partNav</code> consists of 3 main tabs: &ldquo;Home&rdquo;, &ldquo;Store&rdquo; and &ldquo;Admin&rdquo;. <code>ulAttr</code> can be defined like following:</p>
<pre><code>let ulAttr attr xml = tag &quot;ul&quot; attr (flatten xml)
</code></pre>

<p>We want to specify the <code>id</code> attribute here so that our CSS can make the menu nice and shiny.<br />
Add the <code>partNav</code> to main index view, in the &ldquo;header&rdquo; <code>div</code>:</p>
<pre><code>divId &quot;header&quot; [
    h1 (aHref Path.home (text &quot;F# Suave Music Store&quot;))
    partNav
]
</code></pre>

<p>This gives a possiblity to navigate through main features of our Music Store.<br />
It would be good if a visitor to our site could authenticate himself.<br />
To help him with that, we&rsquo;ll put a user partial view next to the navigation menu.<br />
Just as in every other e-commerce website, if a user is logged in, he&rsquo;ll be shown his name and a &ldquo;Log off&rdquo; link.<br />
Otherwise, we&rsquo;ll just display a &ldquo;Log on&rdquo; link.<br />
First, open up the <code>Path</code> module and define routes for <code>logon</code> and <code>logoff</code> in <code>Account</code> submodule:</p>
<pre><code>module Account =
    let logon = &quot;/account/logon&quot;
    let logoff = &quot;/account/logoff&quot;
</code></pre>

<p>Next, define <code>partUser</code> in the <code>View</code> module:</p>
<pre><code>let partUser (user : string option) = 
    divId &quot;part-user&quot; [
        match user with
        | Some user -&gt; 
            yield text (sprintf &quot;Logged on as %s, &quot; user)
            yield aHref Path.Account.logoff (text &quot;Log off&quot;)
        | None -&gt;
            yield aHref Path.Account.logon (text &quot;Log on&quot;)
    ]
</code></pre>

<blockquote>
<p>Note: Because we&rsquo;re inside pattern matching, the <code>yield</code> keyword is mandatory here.</p>
</blockquote>
<p>and include it in &ldquo;header&rdquo; <code>div</code> as well&rdquo;</p>
<pre><code>divId &quot;header&quot; [
    h1 (aHref Path.home (text &quot;F# Suave Music Store&quot;))
    partNav
    partUser (None)
]
</code></pre>

<p>The only argument to <code>partUser</code> is an optional username - if it exists, then the user is authenticated.<br />
For now, we assume no user is logged on, thus we hardcode the <code>None</code> in call to <code>partUser</code>.</p>
<p>There&rsquo;s no handler for the <code>logon</code> route yet, so we need to create one.<br />
Logon view will be rather straightforward - just a simple form with username and password.</p>
<pre><code>type Logon = {
    Username : string
    Password : Password
}

let logon : Form&lt;Logon&gt; = Form ([],[])
</code></pre>

<p>Above snippet shows how the <code>logon</code> form can be defined in our <code>Form</code> module.<br />
<code>Password</code> is a type from Suave library and helps to determine the input type for HTML markup (we don&rsquo;t want anyone to see our secret pass as we type it).</p>
<pre><code>let logon = [
    h2 &quot;Log On&quot;
    p [
        text &quot;Please enter your user name and password.&quot;
    ]

    renderForm
        { Form = Form.logon
          Fieldsets = 
              [ { Legend = &quot;Account Information&quot;
                  Fields = 
                      [ { Label = &quot;User Name&quot;
                          Xml = input (fun f -&gt; &lt;@ f.Username @&gt;) [] }
                        { Label = &quot;Password&quot;
                          Xml = input (fun f -&gt; &lt;@ f.Password @&gt;) [] } ] } ]
          SubmitText = &quot;Log On&quot; }
]
</code></pre>

<p>As I promised, nothing fancy here.<br />
We&rsquo;ve already seen how the <code>renderForm</code> works, so the above snippet is just another plain HTML form with some additional instructions at the top.</p>
<p>The GET handler for <code>logon</code> is also very simple:</p>
<pre><code>let logon =
    View.logon
    |&gt; html
</code></pre>

<pre><code>path Path.Account.logon &gt;&gt;= logon
</code></pre>

<p>Things get more complicated with regards to the POST handler.<br />
As a gentle introduction, we&rsquo;ll add logic to verify passed credentials - by querying the database (<code>Db</code> module):</p>
<pre><code>let validateUser (username, password) (ctx : DbContext) : User option =
    query {
        for user in ctx.``[dbo].[Users]`` do
            where (user.UserName = username &amp;&amp; user.Password = password)
            select user
    } |&gt; firstOrNone
</code></pre>

<p>The snippet makes use of <code>User</code> type alias:</p>
<pre><code>type User = DbContext.``[dbo].[Users]Entity``
</code></pre>

<p>Now, in the <code>App</code> module add two more <code>open</code> statements:</p>
<pre><code>open System
...
open Suave.State.CookieStateStore
</code></pre>

<p>and add a couple of helper functions:</p>
<pre><code>let passHash (pass: string) =
    use sha = Security.Cryptography.SHA256.Create()
    Text.Encoding.UTF8.GetBytes(pass)
    |&gt; sha.ComputeHash
    |&gt; Array.map (fun b -&gt; b.ToString(&quot;x2&quot;))
    |&gt; String.concat &quot;&quot;

let session = statefulForSession

let sessionStore setF = context (fun x -&gt;
    match HttpContext.state x with
    | Some state -&gt; setF state
    | None -&gt; never)

let returnPathOrHome = 
    request (fun x -&gt; 
        let path = 
            match (x.queryParam &quot;returnPath&quot;) with
            | Choice1Of2 path -&gt; path
            | _ -&gt; Path.home
        Redirection.FOUND path)
</code></pre>

<p>Comments:</p>
<ul>
<li><code>passHash</code> is of type <code>string -&gt; string</code> - from a given string it creates a SHA256 hash and formats it to hexadecimal. That&rsquo;s how users&rsquo; passwords are stored in our database.</li>
<li><code>session</code> for now is just an alias to <code>statefulForSession</code> from Suave, which initializes a user state for a browsing session. We will however add extra argument to the <code>session</code> function in a few minutes, that&rsquo;s why we might want to have it extracted already.</li>
<li><code>sessionStore</code> is a higher-order function, taking <code>setF</code> as a parameter - which in turn can be used to read from or write to the session store.</li>
<li><code>returnPathOrHome</code> tries to extract &ldquo;returnPath&rdquo; query parameter from the url, and redirects to that path if it exists. If no &ldquo;returnPath&rdquo; is found, we get back redirected to the home page.</li>
</ul>
<p>Now turn for the <code>logon</code> POST handler monster:</p>
<pre><code>let logon =
    choose [
        GET &gt;&gt;= (View.logon |&gt; html)
        POST &gt;&gt;= bindToForm Form.logon (fun form -&gt;
            let ctx = Db.getContext()
            let (Password password) = form.Password
            match Db.validateUser(form.Username, passHash password) ctx with
            | Some user -&gt;
                    Auth.authenticated Cookie.CookieLife.Session false 
                    &gt;&gt;= session
                    &gt;&gt;= sessionStore (fun store -&gt;
                        store.set &quot;username&quot; user.UserName
                        &gt;&gt;= store.set &quot;role&quot; user.Role)
                    &gt;&gt;= returnPathOrHome
            | _ -&gt;
                never
        )
    ]
</code></pre>

<p>Not that bad, isn&rsquo;t it?<br />
What we do first here is we bind to <code>Form.logon</code>.<br />
This means that in case the request is malformed, <code>bindToForm</code> takes care of returning 400 Bad Request status code.<br />
If someone however decides to be polite and fill in the logon form correctly, then we reach the database and ask whether such user with such password exists.<br />
Note, that we have to pattern match the password string in form result (<code>let (Password password) = form.Password</code>).<br />
If <code>Db.validateUser</code> returns <code>Some user</code> then we compose 4 WebParts together in order to correctly set up the user state and redirect user to his destination.<br />
First, <code>Auth.authenticated</code> sets proper cookies which live till the session ends. The second (<code>false</code>) argument specifies the cookie isn&rsquo;t &ldquo;HttpsOnly&rdquo;.<br />
Then we bind the result to <code>session</code>, which as described earlier, sets up the user session state.<br />
Next, we write two values to the session store: &ldquo;username&rdquo; and &ldquo;role&rdquo;.<br />
Finally, we bind to <code>returnPathOrHome</code> - we&rsquo;ll shortly see how this one can be useful.</p>
<p>You might have noticed, that the above code will results in &ldquo;Not found&rdquo; page in case <code>Db.validateUser</code> returns None.<br />
That&rsquo;s because we temporarily assigned <code>never</code> to the latter match.<br />
Ideally, we&rsquo;d like to see some kind of a validation message next to the form.<br />
To achieve that, let&rsquo;s add <code>msg</code> parameter to <code>View.logon</code>:</p>
<pre><code>let logon msg = [
    h2 &quot;Log On&quot;
    p [
        text &quot;Please enter your user name and password.&quot;
    ]

    divId &quot;logon-message&quot; [
        text msg
    ]
...
</code></pre>

<p>Now we can invoke it in two ways:</p>
<pre><code>GET &gt;&gt;= (View.logon &quot;&quot; |&gt; html)

...

View.logon &quot;Username or password is invalid.&quot; |&gt; html
</code></pre>

<p>The first one being GET <code>logon</code> handler, and the other one being returned if provided credentials are incorrect.</p>
<p>Up to this point, we should be able to authenticate with &ldquo;admin&rdquo; -&gt; &ldquo;admin&rdquo; credentials to our application.<br />
This is however not very useful, as there are no handlers that would demand user to be authenticated yet.</p></article></body></html>